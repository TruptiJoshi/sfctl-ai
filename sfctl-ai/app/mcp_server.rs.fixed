use rmcp::{
    ErrorData as McpError,
    model::{CallToolResult, Content, Implementation, ProtocolVersion, ServerCapabilities, ServerInfo},
    handler::server::{tool::ToolRouter, wrapper::Parameters, ServerHandler},
    service::ServiceExt,
    tool, tool_handler, tool_router,
    serde::{Deserialize, Serialize}, // rmcp re-exports serde
};

// ðŸ‘‡ Make rmcp's re-export visible as a crate *named* `schemars` for the derive macro
use rmcp::schemars as schemars;
use schemars::JsonSchema;
use tokio::io::{AsyncRead, AsyncWrite};
use std::pin::Pin;
use std::io::Write;
use std::fs::OpenOptions;

// Define a wrapper for tracing that writes to a file instead
fn log_to_file(message: &str) {
    if let Ok(mut file) = OpenOptions::new()
        .create(true)
        .append(true)
        .open("logs/mcp-server.log") {
        let timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S");
        let _ = writeln!(file, "[{}] {}", timestamp, message);
    }
}

#[derive(Clone)]
pub struct WeatherServer {
    tool_router: ToolRouter<WeatherServer>,
}

impl WeatherServer {
    pub fn new() -> Self {
        Self { tool_router: Self::tool_router() }
    }
}

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct GetWeatherParams {
    /// City name, e.g. "Seattle"
    pub city: String,
}

#[tool_router]
impl WeatherServer {
    #[tool(name = "get_weather", description = "Get a dummy weather report for a city")]
    async fn get_weather(
        &self,
        Parameters(GetWeatherParams { city }): Parameters<GetWeatherParams>,
    ) -> Result<CallToolResult, McpError> {
        // Log the tool call to a file
        log_to_file(&format!("get_weather called with city: {}", city));
        
        let forecast = format!("The weather in {} is sunny, 25Â°C (dummy).", city);
        Ok(CallToolResult::success(vec![Content::text(forecast)]))
    }
}

#[tool_handler]
impl ServerHandler for WeatherServer {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            // IMPORTANT: Using the stable version here instead of the preview version
            protocol_version: ProtocolVersion::V_0_1,
            capabilities: ServerCapabilities::builder().enable_tools().build(),
            server_info: Implementation::new("sfctl-ai", "0.1.0"),
            instructions: Some("This MCP server exposes a dummy tool: get_weather.".into()),
        }
    }
}

pub async fn start_mcp_server() -> Result<(), Box<dyn std::error::Error>> {
    // Create logs directory if it doesn't exist
    if !std::path::Path::new("logs").exists() {
        std::fs::create_dir("logs").ok();
    }

    // Log startup
    log_to_file("MCP Server starting up...");
    
    // Create the server
    let server = WeatherServer::new();
    
    // This will run until the server is explicitly terminated
    log_to_file("Starting server with stdin/stdout transport");
    let result = match server.serve((tokio::io::stdin(), tokio::io::stdout())).await {
        Ok(_) => {
            log_to_file("Server terminated normally");
            Ok(())
        },
        Err(e) => {
            log_to_file(&format!("Server error: {}", e));
            Err(e.into())
        }
    };
    
    // Log shutdown
    log_to_file("MCP Server shutting down...");
    result
}